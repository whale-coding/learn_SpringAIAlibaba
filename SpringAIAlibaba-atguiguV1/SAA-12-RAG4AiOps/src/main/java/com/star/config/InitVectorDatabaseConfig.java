package com.star.config;

import cn.hutool.crypto.SecureUtil;
import jakarta.annotation.PostConstruct;
import org.springframework.ai.document.Document;
import org.springframework.ai.reader.TextReader;
import org.springframework.ai.transformer.splitter.TokenTextSplitter;
import org.springframework.ai.vectorstore.VectorStore;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.Resource;
import org.springframework.data.redis.core.RedisTemplate;

import java.nio.charset.Charset;
import java.util.List;

/**
 * @author 聂建强
 * @date 2026/1/4 11:07
 * @description: 将数据（运维手册）加载到向量数据库中，RAG的索引部分
 */
@Configuration
public class InitVectorDatabaseConfig {
    @Autowired
    private VectorStore vectorStore;
    @Autowired
    private RedisTemplate<String,String> redisTemplate;

    @Value("classpath:ops.txt")
    private Resource opsFile;

    /**
     * 初始化向量数据库,V1.0版本，存在重复加载问题
     */
    // @PostConstruct
    public void init2(){
        // 1.读取文件
        TextReader textReader = new TextReader(opsFile);
        textReader.setCharset(Charset.defaultCharset());

        // 2.文件转换为向量(开启分词)
        List<Document> list = new TokenTextSplitter().transform(textReader.read());

        // 3.写入向量数据库RedisStack
        vectorStore.add(list);
    }

    /**
     * 初始化向量数据库,V2.0版本，解决重复加载问题
     */
    @PostConstruct
    public void init(){
        // 1.读取文件
        TextReader textReader = new TextReader(opsFile);
        textReader.setCharset(Charset.defaultCharset());

        // 2.文件转换为向量(开启分词)
        List<Document> list = new TokenTextSplitter().transform(textReader.read());

        // 向量数据重复问题，使用redis setnx命令处理

        // 去重复版本，使用文件的自定义元数据作为唯一标识
        String sourceMetadata = (String)textReader.getCustomMetadata().get("source");

        String textHash = SecureUtil.md5(sourceMetadata);  // 文件名加密
        String redisKey = "vector-xxx:" + textHash;

        // 判断是否存入过,redisKey如果可以成功插入表示以前没有过，可以假如向量数据
        Boolean retFlag = redisTemplate.opsForValue().setIfAbsent(redisKey, "1");

        System.out.println("****retFlag : "+retFlag);

        if(Boolean.TRUE.equals(retFlag))
        {
            // 键不存在，首次插入,可以保存进向量数据库
            vectorStore.add(list);
        }else {
            // 键已存在，跳过或者报错
            // throw new RuntimeException("---重复操作");
            System.out.println("------向量初始化数据已经加载过，请不要重复操作");
        }
    }
}
